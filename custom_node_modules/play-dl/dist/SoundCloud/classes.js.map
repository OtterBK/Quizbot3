{"version":3,"file":"classes.js","sourceRoot":"","sources":["../../play-dl/SoundCloud/classes.ts"],"names":[],"mappings":"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","sourcesContent":["import { request, request_stream } from '../Request';\nimport { Readable } from 'node:stream';\nimport { IncomingMessage } from 'node:http';\nimport { StreamType } from '../YouTube/stream';\nimport { Timer } from '../YouTube/classes/LiveStream';\nimport { PlaylistJSON, SoundTrackJSON } from './constants';\n\nexport interface SoundCloudUser {\n    /**\n     * SoundCloud User Name\n     */\n    name: string;\n    /**\n     * SoundCloud User ID\n     */\n    id: string;\n    /**\n     * SoundCloud User URL\n     */\n    url: string;\n    /**\n     * SoundCloud Class type. == \"user\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud User Verified status\n     */\n    verified: boolean;\n    /**\n     * SoundCloud User Description\n     */\n    description: string;\n    /**\n     * SoundCloud User First Name\n     */\n    first_name: string;\n    /**\n     * SoundCloud User Full Name\n     */\n    full_name: string;\n    /**\n     * SoundCloud User Last Name\n     */\n    last_name: string;\n    /**\n     * SoundCloud User thumbnail URL\n     */\n    thumbnail: string;\n}\n\nexport interface SoundCloudTrackDeprecated {\n    /**\n     * SoundCloud Track fetched status\n     */\n    fetched: boolean;\n    /**\n     * SoundCloud Track ID\n     */\n    id: number;\n    /**\n     * SoundCloud Class type. == \"track\"\n     */\n    type: 'track';\n}\n\nexport interface SoundCloudTrackFormat {\n    /**\n     * SoundCloud Track Format Url\n     */\n    url: string;\n    /**\n     * SoundCloud Track Format preset\n     */\n    preset: string;\n    /**\n     * SoundCloud Track Format Duration\n     */\n    duration: number;\n    /**\n     * SoundCloud Track Format data containing protocol and mime_type\n     */\n    format: {\n        protocol: string;\n        mime_type: string;\n    };\n    /**\n     * SoundCloud Track Format quality\n     */\n    quality: string;\n}\n/**\n * SoundCloud Track Class\n */\nexport class SoundCloudTrack {\n    /**\n     * SoundCloud Track Name\n     */\n    name: string;\n    /**\n     * SoundCloud Track ID\n     */\n    id: number;\n    /**\n     * SoundCloud Track url\n     */\n    url: string;\n    /**\n     * User friendly SoundCloud track URL\n     */\n    permalink: string;\n    /**\n     * SoundCloud Track fetched status\n     */\n    fetched: boolean;\n    /**\n     * SoundCloud Class type. === \"track\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud Track Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * SoundCloud Track Duration in miili seconds\n     */\n    durationInMs: number;\n    /**\n     * SoundCloud Track formats data\n     */\n    formats: SoundCloudTrackFormat[];\n    /**\n     * SoundCloud Track Publisher Data\n     */\n    publisher: {\n        name: string;\n        id: number;\n        artist: string;\n        contains_music: boolean;\n        writer_composer: string;\n    } | null;\n    /**\n     * SoundCloud Track thumbnail\n     */\n    thumbnail: string;\n    /**\n     * SoundCloud Track user data\n     */\n    user: SoundCloudUser;\n    /**\n     * Constructor for SoundCloud Track Class\n     * @param data JSON parsed track html data\n     */\n    constructor(data: any) {\n        this.name = data.title;\n        this.id = data.id;\n        this.url = data.uri;\n        this.permalink = data.permalink_url;\n        this.fetched = true;\n        this.type = 'track';\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\n        this.durationInMs = Number(data.duration);\n        if (data.publisher_metadata)\n            this.publisher = {\n                name: data.publisher_metadata.publisher,\n                id: data.publisher_metadata.id,\n                artist: data.publisher_metadata.artist,\n                contains_music: Boolean(data.publisher_metadata.contains_music) || false,\n                writer_composer: data.publisher_metadata.writer_composer\n            };\n        else this.publisher = null;\n        this.formats = data.media.transcodings;\n        this.user = {\n            name: data.user.username,\n            id: data.user.id,\n            type: 'user',\n            url: data.user.permalink_url,\n            verified: Boolean(data.user.verified) || false,\n            description: data.user.description,\n            first_name: data.user.first_name,\n            full_name: data.user.full_name,\n            last_name: data.user.last_name,\n            thumbnail: data.user.avatar_url\n        };\n        this.thumbnail = data.artwork_url;\n    }\n    /**\n     * Converts class to JSON\n     * @returns JSON parsed Data\n     */\n    toJSON(): SoundTrackJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            url: this.url,\n            permalink: this.permalink,\n            fetched: this.fetched,\n            durationInMs: this.durationInMs,\n            durationInSec: this.durationInSec,\n            publisher: this.publisher,\n            formats: this.formats,\n            thumbnail: this.thumbnail,\n            user: this.user\n        };\n    }\n}\n/**\n * SoundCloud Playlist Class\n */\nexport class SoundCloudPlaylist {\n    /**\n     * SoundCloud Playlist Name\n     */\n    name: string;\n    /**\n     * SoundCloud Playlist ID\n     */\n    id: number;\n    /**\n     * SoundCloud Playlist URL\n     */\n    url: string;\n    /**\n     * SoundCloud Class type. == \"playlist\"\n     */\n    type: 'track' | 'playlist' | 'user';\n    /**\n     * SoundCloud Playlist Sub type. == \"album\" for soundcloud albums\n     */\n    sub_type: string;\n    /**\n     * SoundCloud Playlist Total Duration in seconds\n     */\n    durationInSec: number;\n    /**\n     * SoundCloud Playlist Total Duration in milli seconds\n     */\n    durationInMs: number;\n    /**\n     * SoundCloud Playlist user data\n     */\n    user: SoundCloudUser;\n    /**\n     * SoundCloud Playlist tracks [ It can be fetched or not fetched ]\n     */\n    tracks: SoundCloudTrack[] | SoundCloudTrackDeprecated[];\n    /**\n     * SoundCloud Playlist tracks number\n     */\n    tracksCount: number;\n    /**\n     * SoundCloud Client ID provided by user\n     * @private\n     */\n    private client_id: string;\n    /**\n     * Constructor for SoundCloud Playlist\n     * @param data JSON parsed SoundCloud playlist data\n     * @param client_id Provided SoundCloud Client ID\n     */\n    constructor(data: any, client_id: string) {\n        this.name = data.title;\n        this.id = data.id;\n        this.url = data.uri;\n        this.client_id = client_id;\n        this.type = 'playlist';\n        this.sub_type = data.set_type;\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\n        this.durationInMs = Number(data.duration);\n        this.user = {\n            name: data.user.username,\n            id: data.user.id,\n            type: 'user',\n            url: data.user.permalink_url,\n            verified: Boolean(data.user.verified) || false,\n            description: data.user.description,\n            first_name: data.user.first_name,\n            full_name: data.user.full_name,\n            last_name: data.user.last_name,\n            thumbnail: data.user.avatar_url\n        };\n        this.tracksCount = data.track_count;\n        const tracks: any[] = [];\n        data.tracks.forEach((track: any) => {\n            if (track.title) {\n                tracks.push(new SoundCloudTrack(track));\n            } else\n                tracks.push({\n                    id: track.id,\n                    fetched: false,\n                    type: 'track'\n                });\n        });\n        this.tracks = tracks;\n    }\n    /**\n     * Fetches all unfetched songs in a playlist.\n     *\n     * For fetching songs and getting all songs, see `fetched_tracks` property.\n     * @returns playlist class\n     */\n    async fetch(): Promise<SoundCloudPlaylist> {\n        const work: any[] = [];\n        for (let i = 0; i < this.tracks.length; i++) {\n            if (!this.tracks[i].fetched) {\n                work.push(\n                    new Promise(async (resolve) => {\n                        const num = i;\n                        const data = await request(\n                            `https://api-v2.soundcloud.com/tracks/${this.tracks[i].id}?client_id=${this.client_id}`\n                        );\n\n                        this.tracks[num] = new SoundCloudTrack(JSON.parse(data));\n                        resolve('');\n                    })\n                );\n            }\n        }\n        await Promise.allSettled(work);\n        return this;\n    }\n    /**\n     * Get total no. of fetched tracks\n     * @see {@link SoundCloudPlaylist.all_tracks}\n     */\n    get total_tracks(): number {\n        let count = 0;\n        this.tracks.forEach((track) => {\n            if (track instanceof SoundCloudTrack) count++;\n            else return;\n        });\n        return count;\n    }\n    /**\n     * Fetches all the tracks in the playlist and returns them\n     *\n     * ```ts\n     * const playlist = await play.soundcloud('playlist url')\n     *\n     * const tracks = await playlist.all_tracks()\n     * ```\n     * @returns An array of {@link SoundCloudTrack}\n     */\n    async all_tracks(): Promise<SoundCloudTrack[]> {\n        await this.fetch();\n\n        return this.tracks as SoundCloudTrack[];\n    }\n    /**\n     * Converts Class to JSON data\n     * @returns JSON parsed data\n     */\n    toJSON(): PlaylistJSON {\n        return {\n            name: this.name,\n            id: this.id,\n            sub_type: this.sub_type,\n            url: this.url,\n            durationInMs: this.durationInMs,\n            durationInSec: this.durationInSec,\n            tracksCount: this.tracksCount,\n            user: this.user,\n            tracks: this.tracks\n        };\n    }\n}\n/**\n * SoundCloud Stream class\n */\nexport class SoundCloudStream {\n    /**\n     * Readable Stream through which data passes\n     */\n    stream: Readable;\n    /**\n     * Type of audio data that we recieved from normal youtube url.\n     */\n    type: StreamType;\n    /**\n     * Dash Url containing segment urls.\n     * @private\n     */\n    private url: string;\n    /**\n     * Total time of downloaded segments data.\n     * @private\n     */\n    private downloaded_time: number;\n    /**\n     * Timer for looping code every 5 minutes\n     * @private\n     */\n    private timer: Timer;\n    /**\n     * Total segments Downloaded so far\n     * @private\n     */\n    private downloaded_segments: number;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     * @private\n     */\n    private request: IncomingMessage | null;\n    /**\n     * Array of segment time. Useful for calculating downloaded_time.\n     */\n    private time: number[];\n    /**\n     * Array of segment_urls in dash file.\n     */\n    private segment_urls: string[];\n    /**\n     * Constructor for SoundCloud Stream\n     * @param url Dash url containing dash file.\n     * @param type Stream Type\n     */\n    constructor(url: string, type: StreamType = StreamType.Arbitrary) {\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\n        this.type = type;\n        this.url = url;\n        this.downloaded_time = 0;\n        this.request = null;\n        this.downloaded_segments = 0;\n        this.time = [];\n        this.timer = new Timer(() => {\n            this.timer.reuse();\n            this.start();\n        }, 280);\n        this.segment_urls = [];\n        this.stream.on('close', () => {\n            this.cleanup();\n        });\n        this.start();\n    }\n    /**\n     * Parses SoundCloud dash file.\n     * @private\n     */\n    private async parser() {\n        const response = await request(this.url).catch((err: Error) => {\n            return err;\n        });\n        if (response instanceof Error) throw response;\n        const array = response.split('\\n');\n        array.forEach((val) => {\n            if (val.startsWith('#EXTINF:')) {\n                this.time.push(parseFloat(val.replace('#EXTINF:', '')));\n            } else if (val.startsWith('https')) {\n                this.segment_urls.push(val);\n            }\n        });\n        return;\n    }\n    /**\n     * Starts looping of code for getting all segments urls data\n     */\n    private async start() {\n        if (this.stream.destroyed) {\n            this.cleanup();\n            return;\n        }\n        this.time = [];\n        this.segment_urls = [];\n        this.downloaded_time = 0;\n        await this.parser();\n        this.segment_urls.splice(0, this.downloaded_segments);\n        this.loop();\n    }\n    /**\n     * Main Loop function for getting all segments urls data\n     */\n    private async loop() {\n        if (this.stream.destroyed) {\n            this.cleanup();\n            return;\n        }\n        if (this.time.length === 0 || this.segment_urls.length === 0) {\n            this.cleanup();\n            this.stream.push(null);\n            return;\n        }\n        this.downloaded_time += this.time.shift() as number;\n        this.downloaded_segments++;\n        const stream = await request_stream(this.segment_urls.shift() as string).catch((err: Error) => err);\n        if (stream instanceof Error) {\n            this.stream.emit('error', stream);\n            this.cleanup();\n            return;\n        }\n\n        this.request = stream;\n        stream.on('data', (c) => {\n            this.stream.push(c);\n        });\n        stream.on('end', () => {\n            if (this.downloaded_time >= 300) return;\n            else this.loop();\n        });\n        stream.once('error', (err) => {\n            this.stream.emit('error', err);\n        });\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.timer.destroy();\n        this.request?.destroy();\n        this.url = '';\n        this.downloaded_time = 0;\n        this.downloaded_segments = 0;\n        this.request = null;\n        this.time = [];\n        this.segment_urls = [];\n    }\n    /**\n     * Pauses timer.\n     * Stops running of loop.\n     *\n     * Useful if you don't want to get excess data to be stored in stream.\n     */\n    pause() {\n        this.timer.pause();\n    }\n    /**\n     * Resumes timer.\n     * Starts running of loop.\n     */\n    resume() {\n        this.timer.resume();\n    }\n}\n"]}